//
//  LearningPresenter.swift
//  LearnWithMe
//
//  Created by Zvonimir Medak on 12.12.2021..
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import Foundation
import Combine
import CombineExt

final class LearningPresenter {

    // MARK: - Private properties -

    private unowned let view: LearningViewInterface
    private let interactor: LearningInteractorInterface
    private let wireframe: LearningWireframeInterface

    private let questionDifficulty: QuestionDifficulty
    private var currentItem: Int = 1
    private var subscriptions: Set<AnyCancellable> = []

    // MARK: - Lifecycle -

    init(
        view: LearningViewInterface,
        interactor: LearningInteractorInterface,
        wireframe: LearningWireframeInterface,
        questionDifficulty: QuestionDifficulty
    ) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe

        self.questionDifficulty = questionDifficulty
    }
}

// MARK: - Extensions -

extension LearningPresenter: LearningPresenterInterface {

    func configure(with output: Learning.ViewOutput) -> Learning.ViewInput {
        let configurator = ReplaySubject<LearningConfigurator, Never>(bufferSize: 1)
        handle(next: output.next, configurator: configurator)
        handle(previous: output.previous, configurator: configurator)
        handle(output.takeQuiz)
        handleInitialLoad(configurator)
        return Learning.ViewInput(configurator: configurator.asDriver())
    }

}

// MARK: - Private methods -

private extension LearningPresenter {

    func handleInitialLoad(_ configurator: ReplaySubject<LearningConfigurator, Never>) {
        let learningConfigurator = LearningConfigurator(
            definition: questionDifficulty.questions[0].text,
            answer: questionDifficulty.questions[0].answer,
            position: .first
        )
        configurator.send(learningConfigurator)
    }

    func handle(next: Signal<Void>, configurator: ReplaySubject<LearningConfigurator, Never>) {
        next
            .handleEvents(receiveOutput: { [unowned self] in currentItem += 1 })
            .map { [unowned self] in
                return LearningConfigurator(
                    definition: questionDifficulty.questions[currentItem - 1].text,
                    answer: questionDifficulty.questions[currentItem - 1].answer,
                    position: currentItem == questionDifficulty.questions.count ? .last : .middle
                )
            }
            .sink(receiveValue: { configurator.send($0) })
            .store(in: &subscriptions)
    }

    func handle(previous: Signal<Void>, configurator: ReplaySubject<LearningConfigurator, Never>) {
        previous
            .handleEvents(receiveOutput: { [unowned self] in currentItem -= 1 })
            .map { [unowned self] in
                return LearningConfigurator(
                    definition: questionDifficulty.questions[currentItem - 1].text,
                    answer: questionDifficulty.questions[currentItem - 1].answer,
                    position: currentItem == 1 ? .first : .middle
                )
            }
            .sink(receiveValue: { configurator.send($0) })
            .store(in: &subscriptions)
    }

    func handle(_ takeQuiz: Signal<Void>) {
        takeQuiz
            .sink(receiveValue: { [unowned self] in wireframe.navigateToQuestions(questionDifficulty) })
            .store(in: &subscriptions)
    }
}
